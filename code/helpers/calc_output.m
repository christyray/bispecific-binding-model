function output = calc_output(T, Y, net, bal, m, p, singles, interest, ...
    calc, opts)

% CALC_OUTPUT	Calculate simulation output values for specific molecules.
%
%	Calculates different types of output values for specified molecules of
%	interest from the model simulation results.
%
%	USAGE:
%		OUTPUT = CALC_OUTPUT(T, Y, NET, BAL, M, P, SINGLES, INTEREST, ...
%           CALC, OPTS)
%
%	INPUT:
%       T = vector of time values corresponding to the concentrations in Y,
%       given in seconds
%
%       Y = matrix of concentration values output from the ODEs; each
%       column corresponds to an equation in order, each row is a time
%       point
%
%       NET = matrix of net input concentrations output from the ODEs; each
%       column corresponds to an input molecule, each row is a time point
%
%       BAL = matrix of mole balance values output from the ODEs; each
%       column corresponds to an input molecule, each row is a time point
%
%       M = structure containing the molecules included in the model and
%       their assigned numbers, input as a structure, correct naming for
%       species is antibody name or antibody receptor complex name (with
%       components separated by underscores)
%
%       P = structure containing parameters for the model, input as a
%       structure; correct naming for parameters is "kon_" or "koff_",
%       followed by the antibody name or antibody receptor complex name
%       (with components separated by underscores), ending with the
%       receptor being bound to; e.g., kon_BS1_6R_8R
%
%       SINGLES = all of the individual antibodies and receptors that
%       contribute to the bound complexes in BOUND
%
%       INTEREST = a string vector of molecule names of the species of
%       interest for calculations; generated by SELECT_MOLECULES
%
%       CALC = a string specifying which output calculation to use; options
%       are ["conc", "conct", "end", "peak", "auc", "net", "bal", "dydt"]
%
%       OPTS = a structure or table containing the options for the
%       calculations; has two fields: "Add", a logical for whether to sum
%       the output or output each individual molecule, and "Time", a vector
%       or cell array of time points to use for "conct"
%
%	OUTPUT:
%		OUTPUT = a long form table with three columns, one for the time
%		points for the output, one with the species names used in the
%		output calculation, and one with the output values
%
%	NOTES:
%		Uses the default STACK function to generate the long form table for
%		the output.
%
%	See also BINDING_SIM, SETUP_OUTPUT.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Argument Validation

arguments
    T (:,1) double
    Y double
    net double = 0
    bal double = 0
    m struct = struct()
    p struct = struct()
    singles (:,1) string = strings(0)
    interest (:,1) string = names(m)
    calc (1,1) string {mustBeMember(calc, ...
        ["conc", "conct", "end", "peak", "auc", ...
        "net", "bal", "dydt"])} = "conc"
    opts {mustBeA(opts, ["table", "struct"])} = struct()
end

% Remove the time points from a cell array
if class(opts.Time) == "cell"
    opts.Time = opts.Time{:};
end

% Convert type to lowercase to avoid error
calc = lower(calc);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Calculate Model Output

% -------------------- SETUP --------------------
% Number of molecules of interest
n = length(interest);

% Select only molecules of interest
Yn = zeros(length(T), n);
netn = zeros(length(T), n);
for i = 1:n
    Yn(:,i) = Y(:, m.(interest(i)));
    netn(:,i) = net(:, m.(interest(i)));
end

% Select only molecules of interest in mole balance, need to use singles
% instead of m because the mole balance only has values for unpaired
% molecules
if calc == "bal"
    singles_idx = regexpl(singles, interest);
    baln = bal(:, singles_idx);
    interest = singles(singles_idx);
else
    baln = 0;   % To improve performance when the balance isn't needed
end

% Sum output of all molecules if requested
if opts.Add == 1
    Yn = sum(Yn, 2);
    netn = sum(netn, 2);
    baln = sum(baln, 2);

    % Name for output column
    interest = paste(interest, "+");
end

% -------------------- CALCULATIONS --------------------
switch calc
    % Concentration of molecules of interest
    case "conc"
        % Output is just the input concentrations
        outT = T;
        outY = Yn;

    % Concentration of molecules of interest at specific time point(s)
    case "conct"
        nt = length(opts.Time);
        ny = size(Yn, 2);

        % Initialize outputs
        outT = zeros(nt, 1);
        outY = zeros(nt, ny);

        % For each time point
        for i = 1:nt

            % Get index of time closest to requested time point
            diff = abs(T - opts.Time(i));
            [mindiff, idx] = min(diff);
            outT(i) = T(idx);

            % Print warning if there was not an exact match
            if mindiff > 0
                fprintf("Warning: Exact time match not found. " + ...
                    "Difference = %0.1d\n", mindiff);
            end

            % Get concentrations at requested time point
            outY(i,:) = Yn(idx, :);
        end

    % Concentration of molecules of interest at simulation end time
    case "end"
        % Output is concentrations at end point
        outT = T(end);
        outY = Yn(end,:);

    % Maximum concentration of molecules of interest
    case "peak"
        ny = size(Yn, 2);

        % Initialize outputs
        outT = zeros(ny, 1);
        outY = zeros(ny, 1);

        % For each species in the output matrix
        for i = 1:size(Yn, 2)

            % Find peak concentation
            [outY(i), idx] = max(Yn(:,i));
            outT(i) = T(idx);
        end

    % Area under the concentration-time curve for molecules of interest
    case "auc"
        % Calculate AUC
        outT = T(end);
        outY = trapz(T,Yn);

    % Net concentration added to system for each molecule of interest
    case "net"
        % Output is just the net concentrations
        outT = T;
        outY = netn;

    % Mole balance for each molecule added into the system
    case "bal"
        % Output is just the mole balance
        outT = T;
        outY = baln;

    % Derivative for each equation for each time point
    case "dydt"
        outT = T;

        % Calculate derivative for each time point
        dydt = zeros(size(Y));  % Must be calculated for each equation
        for i = 1:length(T)
            dydt(i,:) = binding_eqns(T(i), Y(i,:), m, p);
        end

        % Select only derivatives for molecules of interest
        outY = zeros(length(T), n);
        for i = 1:n
            outY(:,i) = dydt(:, m.(interest(i)));
        end
end

% The peak calculation has a separate time point for each species
if calc == "peak"

    % Create table
    output = table(outT, interest, outY, ...
        'VariableNames', ["Time", "Species", "Value"]);

% The other calculations have one time point for all species
else

    % Generate each column
    Time = repmat(outT, length(interest), 1);     % Stack for each species
    Species = repelem(interest, length(outT), 1); % Repeat for each time
    Value = reshape(outY, [], 1);                 % Make single column

    % Create table
    output = table(Time, Species, Value);
end
end
